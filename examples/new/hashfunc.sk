void hashfunc(int h, int x, int M, ref int ret) {
    ret = ((h * x) % M + M) % M;
}

void prog(ArrayList S, int M, int h, ref boolean collide) {
//    if (h % M.data == 0)
//        h = h + 1;
    assert(h % M != 0);
    boolean[M] So;
    for(int i = 0; i < M; i++)
        So[i] = 0;
    collide = false;
    for(int i = 0; i < S.size; i++)
    {
        int val;
        hashfunc(h, S.elementData[i], M, val);
        if (So[val] == 1)
            collide = true;
        So[val] = 1;
    }
}

void isPrime(int M, ref boolean ret) {
    ret = true;
    for(int i = 2; i*i <= M; i++)
        if(M % i == 0)
            ret = false;
}

void setsize(ArrayList arr, ref int ret) {
    ret = arr.size;
}

void setsizemod(ArrayList arr, int M, ref int ret) {
    boolean[M] So;
    for(int i = 0; i < M; i++)
        So[i] = 0;
    for(int i = 0; i < arr.size; i++)
        So[(arr.elementData[i] % M + M) % M] = 1;
    ret = 0;
    for(int i = 0; i < M; i++)
        ret += So[i];
}


// Library for ArrayList

struct ArrayList {
    int size;
    int[size] elementData;
}

void newArrayList(ref ArrayList ret) {
    int size = 0;
    int[size] elementData;

    ret = new ArrayList(
        size = size,
        elementData = elementData
    );
}

void add(ArrayList arr, int e, ref ArrayList ret) {
    int size = arr.size + 1;

    int[size] elementData;

    elementData[0::arr.size] = arr.elementData[0::arr.size];
    elementData[arr.size] = e;

    ret = new ArrayList(
        size = size,
        elementData = elementData
    );
}

void size(ArrayList arr, ref int ret) {
    ret = arr.size;
}

void get(ArrayList arr, int idx, ref int ret) {
    if (idx < 0 || idx >= arr.size) {
        ret = -1; // -1 for error
    } else {
        ret = arr.elementData[idx];
    }
}

